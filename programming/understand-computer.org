
1. hello.c -> hello.i 预处理
2. hello.i -> hello.s 编译
3. hello.s -> hello.o 汇编
4. hello.o -> hello 链接

存储层次
1. L0: 寄存器文件
2. L1: 1级cache (SRAM)
3. L2: 2级cache (SRAM)
4. L3: 主存 (DRAM)
5. L4: 本地二级存储： 磁盘
6. L5: 远程二级存储

所有应用程序对硬件的操作都必须通过操作系统.

一个字节包含8位。
00000000(0) - 11111111(255).
通常用十六进制来书写位模式，因为2进制写起来太麻烦。
一个字节用16进制表示，值范围是 00 - FF.
在c中，用 0x 或是 0X 开头表示十六进制。
十六进制中的字母可以大写，也可以小写，也可以大小写混合。
0xab0c = 0XAb0c = 0xAB0C

2^n 转换成2进制就是 1后面跟n个0.
比如 2^5 = 100000 = 0x20

短整数(short), 2字节
整数(int), 4字节
长整数(long), 全字长. 如果为64位机器则使用8个字节。
指针：全字长
float, 4字节
double, 8 bytes.

多字节对象的地址是地址最小的字节的地址。
地址小的字节存储高位有效数据，则称为 big endian, 大端法, most IBM, Motorola, Sun machines.
地址小的字节存储低位有效数据，则称为 little endian, 小端法, Intel.

用异或实现两个数的交换
void swap(int *x, int *y)
{
    *x = *x ^ *y;
    *y = *x ^ *y;
    *x = *x ^ *y;
}

掩码运算
x & 0xFF
取x的低8位。
全1的掩码： ~0。1的个数取决于机器字长。

移位
移位运算符 (<<, >>) 从左至右结合。 i << j << k 等价于 (i << j) << k.
它的优先级低于加减符号， i << 5 - 1 等价于 i << (5 - 1)

逻辑右移和算术右移的区别
逻辑右移：高位用0补。
算术右移：高位用最高有效位补。
对于unsigned 数据，右移必须是逻辑的。
对于有符号数据，算术或是逻辑右移均可。
实际上，几乎所有的机器加编译器组合都使用 /算术右移/ 。

无符号整数
n位的无符号数表示的数据范围 0 ~ 2^n -1.

有符号整数
java只支持有符号数。
有符号整数用 /二进制补码/ 表示。
char的最小值二进制表示, 1000 0000; 最大值的二进制表示是 0111 1111.

补码的求值
1000 = -2^3 = -8
1001 = -2^3 + 2^0 = -7

给定负数求补码
-6, 8 - 6 = 2, 非符号位上的和应该是2，所以是 010. -6表示为 1010.
-1 0xff(char), 0xffff(short) 0xffffffff(int, long).
-1 是全1的串.

根据负数补码求对应的正数。
-6 1010 取反(0101) 加1(0110) => 6.

如果你对数值范围不清楚，
可以查看 =/usr/include/limits.h=


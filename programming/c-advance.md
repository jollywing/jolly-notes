

## 奇怪的C代码 ##

> TAG: c, 递增, gcc  
> DATE: 2013-08-05

    int i = 3;
    int ans = (++i)+(++i)+(++i);
    
ans等于多少？我想大多数同学都会和我一样的认为： ans = 4 + 5 + 6 = 15.

而实际结果呢？

- Linux下用gcc编译的结果是16.
- Windows下用VC编译，debug模式的结果是16, Release模式的结果是18.
- VS 2010中不管是Debug模式或是Release模式，结果都是18.

这都是编译器优化的结果，导致结果不确定。
所以应该避免在一行代码中重复出现被递增（递减）的变量。

--------------------

##  内存对齐 ##

> TAG: c, memory  
> DATE: 2013-08-05

### 从一个例子开始 ###

象下面这样定义的结构体占几个字节？

    typedef struct{
        char a;
        int i;
    } Sample;

`char`占1个字节，`int`占4个字节，答案是5个字节？
错了。如果用 _gcc_ 编译，`sizeof(Sample)` 的结果是8个字节。

这是怎么回事？进一步观察，`Sample`第0个字节是`a`，
而`Sample`的成员`int i`从第4个字节开始。
这是编译器为了_内存对齐_所做的优化。

### 什么是内存对齐 ###

比如数据总线有32位，它访存只能4个字节4个字节地进行。
0-3，4-7，8-11，12-15，……
即使我们需要的数据只占一个字节，也是一次读取4个字节。
一个字节的数据不管地址是什么，都能通过一次访存读取出来，
所以不需要考虑地址对齐的问题。
而如果要读取的数据是一个字节以上，比如两个字节，就要考虑地址对齐的问题。
如果该数据的内存地址是0x03，则需要两次才能读取该数据，
第一次读0x00-0x03，第二次读0x04-0x07。
这个数据就没有进行内存对齐，跨越了访存边界。

而相对CPU的运算来说，访存是非常慢的，所以要尽量减少访存次数。
为了减少跨越访存边界的数据引起的访存开销，
所以编译器会进行内存对齐，即把变量的地址做一些偏移，
目的是一次访存就读出数据，不然的话也要以尽可能少地访存次数读出数据。

如上一个例子中那样，整型成员`i`的地址做4个字节的偏移，
而`Sample`对象的地址也会做4字节边界的对齐，
这样`i`的地址始终是4的倍数，从而使得`i`不跨越访存边界，
能一次读出它的值。

### 尽可能少的内存占用 ###

    typedef struct{
        char a;
        char b;
        int i;
    } Sample1;

`Sample1`占多少空间呢？仍然是8个字节。
`a`在第0个字节，`b`在第1个字节，`i`占4-7字节。
这是内存对齐的原则，占用尽量少的内存。
如果在`b`之后，还有`char`类型的成员`c`和`d`，同样是占8个字节。

### 数据成员顺序影响内存的占用 ###

    typedef struct{
        char a;
        int i;
        char b;
    } Sample2;

`Sample2`的数据成员和`Sample1`的数据成员相同，只是顺序不一样，
是否占用一样多的内存呢？答案是不一样。
`Sample1`占用8字节，而`Sample2`占用12个字节！

这是为什么呢？32位机器上，访存单元是4字节。
对于多于4字节的数据，以4字节为单位做内存对齐的。
所以对于上述的结构体数据的地址分配，都是4的倍数。
对于结构体内部，以数据成员的最大长度为对齐单位。
如果数据成员的长度超过4字节，仍然以4字节为对齐单位，这是因为访存单元就是4字节。
在`Sample2`的定义中，因为`int`是4字节，所以以4字节为内存对齐的单位。

在`Sample2`中，对于`a`来说，只占一个字节，无所谓对不对齐，它在0字节。
`i`是`int`类型，要对齐，在4-7字节。
`b`在8字节，虽然它只占一个字节，但因为结构体内是以4字节为单位对齐的，
所以编译器一下多分配出4个字节，所以共占了12个字节。

以上的`Sample1`和`Sample2`的例子说明，即使是同样的结构体，如果数据成员的顺序不同，所占的内存空间可能是不同的。

### 总结 ###

- 如果我们对内存对齐有概念，在定义结构体的时候就会留心数据成员的顺序，从而能
  减少程序的内存占用。
- 以前我使用变量存放较小的整数时，为了减小内存占用，往往把变量定义成`char`型，
  但现在明白了，因为编译器的内存对齐，节省内存的效果并没有那么理想。
- 如果内存真的很受限，可以用 `#pragma pack(1)` 告诉编译器关闭内存对齐。

--------------------

## 主要的调用惯例 ##

> TAG: 调用惯例, cdecl, stdcall, fastcall, thiscall  
> DATE: 2013-08-06


### 什么是调用惯例 ###

调用惯例(Calling Conventions)指计算机程序执行时调用函数或过程的一些约定，包括：

1. 函数的参数是通过栈还是寄存器传递？
2. 如果通过栈传递，顺序是怎样的，是从左至右入栈还是相反。
3. 谁负责清理栈，是调用者还是被调用者？

从清理栈的角度来讲，调用惯例可分为三类：函数的调用者清理，函数清理，混合清理（有时由调用者清理，有时由函数自己清理）。

### 调用者清理 ###

著名的*cdecl*就是由函数调用者清理栈的调用惯例。
*cdecl*是基于c语言的调用惯例，也是x86机器上大多数C编译器采用的调用惯例。

函数的返回结果多通过*EAX*寄存器返回。
对于32位机器，*EAX*能容纳4个字节。
整数或内存地址（指针），通过EAX寄存器返回是没有问题的。
超过4个字节的结构体呢？如何返回？

通过阅读 <http://en.wikipedia.org/wiki/X86_calling_conventions>，我找到了答案。
对于较小的结构体或对象，可以通过EAX:EDX寄存器对返回。
对于超大的对象或结构体，caller在调用函数之前会分配出内存空间，然后把这个空间地址作为第一个参数隐式地传给函数。被调用的函数callee把结果写进这片内存空间，再pop空间地址，之后才返回。
对于浮点数的结果，似乎是通过 *ST0 x87 register*(浮点寄存器?)返回的。

因为调用者知道为参数分配了多少栈空间，所以由调用者清理栈就有一个好处：
为参数分配的栈空间大小可以动态决定。
因此*cdecl*支持可变参数的函数的调用，例如`printf`。

如果强迫某个函数使用*cdecl*调用惯例，可以在函数声明中加`_cdecl`关键字，如：

    void _cdecl funct();

### 函数自己清理 ###

*pascal*，*stdcall*，*fastcall*都是由函数来清理栈。
通过阅读程序的汇编代码，可以很容易识别这类调用惯例。因为函数返回前会清理栈。

*pascal*是基于*PASCAL*编程语言的函数调用惯例。
参数按照从左到右的顺序压栈（和*cdecl*的入栈顺序相反）。
OS/2 1.x，Microsoft Windows 3.x 和 Borland Delphi 1.x中的16位API都使用这种函数调用惯例。

*stdcall*是从*pascal*调用惯例演变出来的，和*pascal*不同的是，*stdcall*以从右到左的顺序对参数压栈。
返回值存储在EAX寄存器中。Win32 API就是采用的这种调用惯例。

*fastcall*是混合使用寄存器和栈来存储函数的参数，比如把前两个参数存储在寄存器中，其余的参数入栈。
有*Microsoft fastcall*和*Borland fastcall*等不同的实现。

由函数自己清理栈的好处在于：调用者不需要每次调用函数之后都清理栈，从而节省了不少代码，
从而生成的二进制文件比较小。坏处在于，由于清理栈的代码是事先生成在函数体内，
所以不能支持可变参数的函数。

### 混合清理 ###

混合清理的代表是*thiscall*，对C++中非静态成员函数使用的就是这种调用惯例。

对于*gcc*编译器来说，*thiscall*几乎和*cdecl*相同：函数调用者负责清理栈，参数按从右到左的顺序入栈。
不同的是，*thiscall*最后会把`this`指针压栈，就好象它是函数的第一个参数。（其实也是的吧）

对于*Microsoft VC++*编译器，*thiscall*类似于Windows API的*stdcall*，函数的参数从右到左压栈，由参数来清理栈。和*stdcall*不同的是，*thiscall*会通过*ECX*寄存器来传递`this`指针。因为由函数自己清理栈不支持可变参数的函数调用，所以对于可变参数的函数，则由函数的调用者来清理栈。这是*thiscall*的灵活之处。

### 总结 ###

<table border="1">
  <tr><th>调用惯例</th><th>出栈方</th><th>参数传递</th><th>名字修饰</th></tr>
  <tr><td>cdecl</td><td>函数调用方</td><td>从右至左的顺序压参数入栈</td><td>下划线+函数名</td></tr>
  <tr><td>pascal</td><td>函数本身</td><td>从左至右的顺序入栈</td><td>较为复杂，参见pascal文档</td></tr>
  <tr><td>stdcall</td><td>函数本身</td><td>从右至左的顺序压参数入栈</td>
	<td>下划线+函数名+@+参数的字节数， 如函数 int func(int a, double b)的修饰名是 _func@12</td></tr>
  <tr><td>fastcall</td><td>函数本身</td><td>头两个 DWORD(4字节)类型或者更少字节的参数 被放入寄存器，其他剩下的参数按从右至左的顺序入栈</td><td>@+函数名+@+参数的字节数</td></tr>
  <tr><td>thiscall</td><td>不一定</td>
    <td>从右至左的顺序压参数入栈（有时会通过寄存器传递this指针）</td><td>不详</td></tr>
</table>

------------------------------

## C语言中的序列点 ##

> TAG: C, 序列点  
> DATE: 2013-08-07

序列点是程序执行序列中一些特殊的点。
当有序列点存在时，序列点前面的表达式必须求值完毕，并且副作用也已经发生，
才会计算序列点后面的表达式和其副作用。

什么是副作用？举例子来说明。

    int a = 5;
    int b = a ++;

在给*b*赋值的语句中，表达式`a++`就有副作用，它返回`a`当前的值5后，要对`a`进行加1的操作。

哪些符号会生成序列点呢？

### "`,`"会生成序列点。 ###

"`,`"用于把多条语句拼接成一条语句。
例如：

    int b = 5;
    ++ b;

可由"`,`"拼接成

    int b = 5, ++b;

因为"`,`"会产生序列点，所以"`,`"左边的表达式必须先求值，如果有副作用，副作用也会生效。然后才会继续处理"`,`"右边的表达式。

### `&&`和`||`会产生序列点 ###

*逻辑与* `&&` 和*逻辑或* `||` 会产生序列点。

因为`&&`支持短路操作，必须先将`&&`左边的表达式计算完毕，如果结果为`false`，则不必再计算`&&`右边的表达式，直接返回`false`。

`||`和`&&`类似。

### `?:`中的"`?`"会产生序列点 ###

*三元操作符* `?:`中的"`?`"会产生序列点。
如：

    int a = 5;
    int b = a++ > 5? 0 : a;

`b`的结果是什么？因为"`?`"处有序列点，其左边的表达式必须先求值完毕。
`a++ > 5`在和5比较时，`a`并没有自增，所以表达式求值为`false`。
因为"`?`"处的序列点，其左边表达式的副作用也要立即生效，即`a`自增1，变为6。
因为"`?`"左边的表达式求值为`false`，所以三元操作符`?:`返回`:`右边的值`a`。
此时`a`的值是6，所以`b`的值是6。

### 序列点之间的执行顺序 ###

[奇怪的C代码](http://user.qzone.qq.com/39088480/blog/1375715161)中给出的例子。

    int i = 3;
    int ans = (++i)+(++i)+(++i);

`(++i)+(++i)+(++i)`之间并没有序列点，它们的执行顺序如何呢？
*gcc*编译后，先执行两个`++i`，把它们相加后，再计算第三个`++i`，
再相加。而*Microsoft VC++*编译后，先执行三个`++i`，再相加。
两者得到的结果不同，谁对谁错呢？

谁也没有错。C标准规定：**两个序列点之间的执行顺序是任意的**。
当然这个任意是在不违背操作符优先级和结合特性的前提下的。
这个规定的意义是为编译器的优化留下空间。

知道这个规定，我们就应该避免在一行代码中重复出现被递增的同一个变量，
因为编译器的行为不可预测。
试想如果`(++i)+(++i)+(++i)`换成`(++a)+(++b)+(++c)`（其中`a`、`b`、`c`是不同的变量），
不管`++a`，`++b`和`++c`的求值顺序谁先谁后，结果都会是一致的。

## 谁调用了main函数 ##

> TAG: C, main, _start  
> DATE: 2013-08-08

大家都知道，`main`是C程序的入口函数。对写程序的人来说，的确是这样的。
但程序却不是从`main`开始执行的。下面是`main`函数的原型：

    int main(int argc, char *argv[]);

+ 如果程序直接从main开始，谁给main传入的argc, argv呢？
+ 全局变量在`main`之外，它们之前就存在，在main退出后依然存在。
  为它们分配空间的工作肯定是在进入`main`之前完成的，
  对全局变量的回收工作，也是在退出`main`之后进行的。
+ 对于c++程序，全局对象的构造和析构肯定也是在`main`之外进行的。
+ *stdout*, *stdin*, *stderr*这些标准输入输出，肯定在`main`之前被打开了，
  不然我们不能在自己的程序中`printf`，`getchar`等。

实际上，ELF可执行文件的入口点并不是`main`而是`_start`。
程序执行后，先执行的是*stdlib*库中的`_start`函数。
`_start`在又调用了`main`。
而且他在调用`main`之前还调用了`_init`函数，在`main`之后还调用了`_exit`函数。

至于怎么得到这一结论，可参见以下几篇文章：

1. <https://github.com/1184893257/simplelinux/blob/master/main.md#top>。
2. <http://www.cppblog.com/liu1061/articles/53762.html>。


## Linux下程序的加载、运行和终止流程 ##

> TAG: linux, main, _start  
> DATE: 2013-08-08  
> 原文地址: <http://blog.csdn.net/tigerscorpio/article/details/6227730>

### 简介 ###

用户在编写程序时都要定义一个main()函数作为程序运行的入口。程序开始 执行时就
从这个函数开始。当这个函数返回时就表明程序运行结束了。可是用户编写的 程序要
能正确运行远不是这么简单。比如，我们不禁要问main()是由谁调用 的呢？当从
main()返回后又运行到哪里去了呢？C++程序中定义的全局对象 是如何构造的呢？又是
如何析构的呢？如果程序是动态链接的，它所依赖的共享库是 如何加载进内存的？更
复杂的是，共享对象中的全局对象是如何构造的和析构的呢？ 要回答这些问题，就不
得不弄清程序加载、运行和终止的整个流程，从中也可以知道 系统软件（包括操作系
统、动态链接器、链接编辑器和编译器）为了支持用户程序的 正确运行做了多么复杂
的工作。

为了支持用户程序的正确运行需要解决以下几个重要问题：

- 加载用户程序以及它所依赖的所有共享对象；
- 对用户程序和共享对象进行符号解析和*重定位*；
- 向用户程序传递环境变量和命令行参数。
- 根据C++标准的规定，全局对象（包括用户程序和共享库中定义的）必须 在main()执
  行前初始化，并在程序结束时以相反的顺序析构。
 

为了理清这些问题，下面我们来分析Linux系统下程序的运行流程。

### 术语 ###

#### 程序头(Program Header) ####

程序头在[gabi]的Program Header一节中定义，是ELF文件执行视图的重 要部分。它规
定了ELF文件中的哪些部分段需要加载以及加载的地址以及是否需要动 态链接器等信息。
若需要动态链接器，程序头中的`PT_INTERP`指定了动态 链接器的路径。

#### 初始化代码和终止代码(Initialization and Termination code) ####

每个可执行文件和共享对象都有初始化代码和终止代码。初始化代码在用户程序开始执行前执行。所有的共享对象的初始化代码在可执行文件获得控制权之前执行。终止代码则在进程退出时执行，顺序与初始化代码执行的顺序相反。共享对象的初始化代码和终止代码由动态连接器负责执行。(Initialization and Termination Functions, [gabi])

#### 加载时重定位（Load-time Relocation）和运行时重定位（Run-time Relocation） ####

加载时重定位指在动态链接器加载对象文件后就进行的重定位，而运行时重定位 是指在用户程序已开始运行后在需要的情况下进行的重定位。PLT表的重定位就属于运行时重定位。在PLT表的帮助下，当第一次调用一个函数时进行重定位，以后再调用时就不用重定位了。若这个函数不被调用则不需要重定位，这可省去加载时重定位的时间。详见[abi386-4]的Procedure Linkage Table一节。

### 程序运行的基本流程 ###

首先给出一个大致的流程。

1. 操作系统运行用户程序时将其映射到内存中；
2. 当它看到可执行文件中的`PT_INERP`时，操作系统将`PT_INTERP`指定的动态链接器映射进内存，并通过栈向其传递它所需要的参数，并跳到动态链接器的入口处开始执行；
3. 动态链接器开始自举（Bootstrap），对自己进行重定位，并开始构造符号表；
4. 自举完成后，动态链接器根据可执行文件.dynamic段中的`DT_NEEDED`元素开始加载依赖的共享对象，并加入它的符号表。如果这个共享对象依赖其它的共享对象，动态链接器也会加载它们。当这个过程结束时，所有需要的共享对象都已加载进内存，动态链接器也具有了程序和所有共享库的符号表。
5. 这时，动态链接器重新遍历共享库，并进行加载时重定位（注意加载时重定位采用依赖图的后序遍历顺序进行。也就是说如果A对象依赖B对象，则先处理B对象再 处理A对象）。加载时重定位包括：
  + 对数据的引用，在.rel.dyn段中，需要初始化一个 GOT（在.got中）项为一个 全局符号的地址；
  + 对代码的引用（在.rel.plt段中），需要初始化一个 GOT（在.got.plt)项为PLT表中第二条指令的地址（Procedure Linkage Table, [abi386-4]）。
6. 如果共享对象有初始化代码（在.init中，全局对象的初始化就是这样实 现的），动态链接器会执行它，并将终止代码（在.fini中，全局对象的 析构就是这样实现的）记录下来以便退出时执行。动态链接器不会执行用户程序的 初始化代码，它由用户程序的启动代码自己执行。这个过程完成后，所有的共享对 象都已重定位并初始化，动态链接器跳到用户程序的入口处开始执行。注意，为了 能在程序退出时让动态链接器有机会调用共享对象的终止代码，动态链接器会传递 一个终止函数（用以调用共享对象的终止代码）给用户程序。
7. 用户程序开始执行。首先它注册动态链接器的终止函数和它自己的终止函数， 然后调用用户程序的初始化代码，然后调用用户定义的main()函数。 main()函数返回后，以注册的相反顺序调用终止函数（也就是说先调用 用户程序的终止函数，再调用动态链接器的终止函数），最后调用_exit()退出进程。

详见[Levine]第10章。

下面结合实际代码给出Linux下详细的运行流程。

### 程序的加载 ###

程序的加载是通过执行exec(3)系统调用实现的。当在命令行上执行一个程序 或在图形界面系统中双击一个可执行文件时最终都是通过这个系统调用来执行程序的。 执行这个系统调用后，陷入操作系统内核，由操作系统负责加载该程序文件。在操作系 统确认相关参数后，然后通过内存映射方式加载进内存。若该ELF文件是动态链接的可执行文件（程序头中存在`PT_INTERP`）需要动态连接器的支持，操作系统则将该动态连接器映射进内存，并准备好相应的环境，将控制权转移给动态连接器。若ELF文件是静态链接的，则操作系统准备好环境后直接转移到ELF文件的入口点开始执行。详细过程如下：

1. 执行exec(3)调用后陷入操作系统内核，检查参数，并判断可执行文件的类型。因为Linux支持的可执行文件不止一种类型，加载不同类型的文件方法不一样。下面假设文件类型为ELF。
2. 检查ELF文件格式的有效性，读入程序头（Program Header），并检查是否存在`PT_INTERP`项。存在的话说明该文件是动态链接的可执行文件，需要动态连接器的支持。
3. 根据ELF文件程序头的信息对ELF文件进行映射，通常包括两个段：代码段和数据段。
4. 初始化进程运行的堆栈环境，在栈中存储环境变量、命令行参数以及需要传给动态连接器的一些附加参数（Auxiliary Vector）。（见[abi386-4]的图3-31）
5. 若ELF文件是静态链接的可执行文件，跳转到用户程序入口点（由其程序头定义）开始执行；若ELF文件是动态链接的可执行文件，映射动态连接器，并跳转到动态连接器的入口处开始执行。
 
另见[abi386-4]的第5节，[gabi]的Dynamic Linking.

### 运行动态连接器 ###

对于动态链接的可执行文件，还需要动态连接器为其加载可执行文件依赖的共享对象文件并进行符号重定位才可以执行。动态连接器的位置存储在可执行文件程序头的`PT_INTERP`元素中（见[gabi]Program Header一节）。动态连接器的运行过程如下：

1. 动态连接器的入口是`_start`， 在`glibc/sysdeps/i386/dl-machine.h`中的`RTLD_START`宏中定义。它首先调用`_dl_start()`(glibc/elf/rtld.c)。
2. `_dl_start()`首先对动态连接器自己进行重定位，最后调用`_dl_start_final()`(glibc/elf/rtld.c)收集一些基本的运行时信息后调用`_dl_sysdep_start()`(glibc/elf/dl-sysdep.c)。
3. `_dl_sysdep_start()`首先处理由操作系统建立的环境信息（Figure 3-31, p.28, [abi386-4]），设置相关参数(`_dl_argc`: 命令行参数的个数，`_dl_argv`: 命令行参数数组，`_environ`: 环境数组，`_dl_auxv`: 传递给动态连接器的附加参数数组)，在读入`_dl_auxv`数组存储的信息，最后调用`_dl_main()` (glibc/elf/rtld.c)进行动态连接器的主要任务。
4.  `_dl_main()`非常长，主要工作是加载可执行文件依赖的所有共享对象，构造符号表，并进行加载时重定位（有些重定位可以延迟到需要时再进行，称为运行时重定位）。考虑到`R_386_COPY`（见[abi386-4]的78页）重定位类型，要特别加载时重定位的顺序。下面是摘自`_dl_main()`中的一段注释。

    > /* Now we have all the objects loaded. Relocate them all except for the dynamic linker itself. We do this in reverse order so that copy relocs of earlier objects overwrite the data written by later objects. We do not re-relocate the dynamic linker itself in this loop because that could result in the GOT entries for functions we call being changed, and that would break us. It is safe to relocate the dynamic linker out of order because it has no copy relocs (we know that because it is self-contained). */

    简单地说，先重定位一个对象文件所依赖的所有对象文件再重定位这个对象文件。 重定位完成后返回到`_dl_sysdep_start()`，然后返回到`_dl_start_final()`，然后再返回到`_dl_start()`，继续返回到`_start`。
5. `_start`调用动态连接器的初始化函数（以调用每个共享对象的初始化代码），并把动态连接器的终止函数（以调用每个共享对象的终止代码）地址存入EDX寄存器以传给可执行文件，然后跳转到可执行文件的入口处开始执行。
 
动态连接器任务完成后将控制权转移给用户程序，此时用户程序才正是开始执行。

### 用户程序的执行 ###

不管用户程序是静态的还是动态的可执行文件，它们的入口处都在`_start`(glibc/sysdeps/i386/elf/Start.S)。它首先设置好一些寄存器后调用`__libc_start_main()`(glibc/csu/libc-start.c)。 `__libc_start_main()`主要进行以下工作:

1. 调用`__cxa_atexit()`(`glibc/stdlib/cxa_atexit.c`)注册动态连接器通过EDX寄存器传过来的终止函数。
2. 调用`__cxa_atexit()`注册用户程序的终止函数
3. 调用用户程序的初始化函数
4. 调用用户提供的`main()`函数
5. `main()`返回后调用`exit()` (glibc/stdlib/exit.c)。`exit()`以注册的相反顺序调用`atexit()`(glibc/stdlib/atexit.c)和`__cxa_atexit()`注册的函数，然后调用`_exit()`结束进程。
 

### 参考文献 ###

1. [abi386-4] System V Application Binary Interface: Intel386 Architecture Processor Supplement, Fourth Edition.
2. [gabi4] System V Application Binary Interface, 2001.
3. [Levine] John R. Levine, Linkers and Loaders.
4. Glibc源代码。

## ODesk调研 ##

> TAG: ODesk, c, cpp, java  
> DATE: 2013-08-12

### C/CPP ###

1. GUI: *gtk* OR *MFC*.
2. UI 中嵌入浏览器窗口.
3. 执行web搜索，提取搜索结果。
4. 屏幕截图
4. *mingw* on Linux

<!-- vim: set ft=txt: -->

1.八十年代早期，APRP在加利福尼亚大学的伯克利分校将TCP/IP第一次实现在UNIX系统上，这就是广为人知的socket接口。
2.每个打开的socket都对应一个整数，我们称它为socket描述符，该整数也是socket描述符在文件描述符表中的索引值。但socket描述符在描述符表中的表项并不指向文件表，而是指向一个与该socket有关的数据结构。
3.在使用TCP协议时，一般服务端进程先使用socket调用得到一个描述符，然后使用bind调用将一个名字与socket描述符连接起来，对于Internet域就是将Internet地址联编到socket。之后，服务端使用listen调用指出等待服务请求队列的长度。然后就可以使用accept调用等待客户端发起连接（一般是阻塞等待连接，后面章节会讲到非阻塞的方式），一旦有客户端发出连接，accept返回客户的地址信息，并返回一个新的socket描述符，该描述符与原先的socket有相同的特性，这时服务端就可以使用这个新的socket进行读写操作了。一般服务端可能在accept返回后创建一个新的进程进行与客户的通信，父进程则再到accept调用处等待另一个连接。客户端进程一般先使用socket调用得到一个socket描述符，然后使用connect向指定的服务器上的指定端口发起连接，一旦连接成功返回，就说明已经建立了与服务器的连接，这时就可以通过socket描述符进行读写操作了。
使用无连接的UDP协议时，服务端进程创建一个socket，之后调用recvfrom接收客户端的数据报，然后调用sendto将要返回客户端的消息发送给客户进程。客户端也要先创建一个socket，再使用sendto向服务端进程发出请求，使用recvfrom得到返回的消息。 
4.按照OSI七层协议的描述，传输层与网络层在功能上的最大区别是传输层提供进程通信能力。从这个意义上讲，网络通信的最终地址就不仅仅是主机地址了，还包括可以描述进程的某种标识符。为此，TCP/IP协议提出了协议端口（protocol port，简称端口）的概念，用于标识通信的进程。
端口是一种抽象的软件结构（包括一些数据结构和I/O缓冲区）。应用程序（即进程）通过系统调用与某端口建立连接（binding）后，传输层传给该端口的数据都被相应进程所接收，相应进程发给传输层的数据都通过该端口输出。在TCP/IP协议的实现中，端口操作类似于一般的I/O操作，进程获取一个端口，相当于获取本地唯一的I/O文件，可以用一般的读写原语访问之。
5. 在OSI的术语中，网络层及其以下各层又称为通信子网，只提供点到点通信，没有程序或进程的概念。而传输层实现的是"端到端"通信，引进网间进程通信概念，同时也要解决差错控制，流量控制，数据排序（报文排序），连接管理等问题.
6.Berkeley Software Distribution = BSD

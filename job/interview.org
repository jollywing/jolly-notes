
* Basic
** ASCII码表
* 软件工程
** 软件工程的六个阶段
一，项目计划阶段（可行性分析阶段），撰写可行性分析报告。
二，项目需求分析阶段。将用户的需求用逻辑的软件工程语言表达出来，设计好功能和数据库模型，编写成软件需求设计书。
三，项目设计阶段。
概要设计就是设计软件的结构，包括模块设计，系统的总体数据结构和数据库结构。概要设计阶段通常得到软件结构图。
详细设计阶段就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。
详细设计阶段常用的描述方式有：流程图、N-S图、PAD图、伪代码等。

四，编码阶段。
为程序员分配好编码任务，将软件的设计具体为软件代码。
这里注意的是编码语言，工具，环境和编码规范。

五，软件测试阶段。
首先是人工测试：个人复查，抽查和会审。

然后是机器测试。
软件测试就是利用测试工具按照测试方案和流程对产品进行功能和性能测试，甚至根据需要编写不同的测试工具，设计和维护测试系统，对测试方案可能出
现的问题进行分析和评估。执行测试用例后，需要跟踪故障，以确保开发的产品适合需求。

测试，目的是以较小的代价发现尽可能多的错误。
要实现这个目标的关键在于设计一套出色的测试用例。
如何才能设计出一套出色的测试用例，关键在于理解测试方法。
不同的测试方法有不同的测试用例设计方法。
两种常用的测试方法是白盒法测试对象是源程序，依据的是程序内部的的逻辑结构来发现软件的编程错误、结构错误和数据错误。
结构错误包括逻辑、数据流、初始化等错误。用例设计的关键是以较少的用例覆盖尽可能多的内部程序逻辑结果。
白盒法和黑盒法依据的是软件的功能或软件行为描述，发现软件的接口、功能和结构错误。
其中接口错误包括内部/外部接口、资源管理、集成化以及系统错误。

六，维护阶段。

对软件正式交付使用过程中出现的软件的bug进行修复，调整软件以适应正式环境，编写软件的维护报告。

以上是我在搜索软件工程方面的资料时候简单的描述了软件工程的阶段。
但是个人感觉很多项目在正式过程中只有四个阶段，即需求分析，软件设计，编码，测试，这是最重要的四个阶段。
计划阶段和维护阶段没有，也不能说没有，只是这2个阶段应该说不明显。
* C
** 预编译
什么是预编译？什么时候需要预编译？
** 关键字
*** volatile
** 函数指针
*** 定义
: void (*func)(int);
: char (*get_char)(char);
: typedef void (*) () FuncPtr;
* C++
** 虚表的实现
** Template
** struct
c++中 struct 和 class 的主要区别在于默认的存取权限不同,
struct 默认为 public, 而 class 默认为 private
* OS
** 实时操作系统
实时操作系统贵在实时，要求在规定的时间内完成某种操作。主要用在工业控制中，实
时操作系统中一般任务数是固定的，有硬实时和软实时之分，硬实时要求在规定的时间
内必须完成操作，这是在操作系统设计时保证的；软实时则没有那么严，只要按照任务
的优先级，尽可能快地完成操作即可。我们通常使用的操作系统在经过一定改变之后就
可以变成实时操作系统。

实时系统需要可抢占式内核。
*** 内核抢占（可抢占式内核）：
即当进程位于内核空间时，有一个更高优先级的任务出现时，如果当前内核允许抢占，则可以将当前任务挂起，执行优先级更高的进程。
*** 非抢占式内核：
高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占CPU运行。进程一旦处于核心态(例如用户进程执行系统调用)，则除非进程自愿放弃CPU，否则该进程将一直运行下去，直至完成或退出内核。
** Linux内存管理和Windows内存管理有何不同
** Big endian vs Little endian
big endian, little endian
Motorola, PowerPC, big endian, [12|34|56|78]
Intel, x86, little endian, [78|56|34|12]
Java编译的程序全是用big endian，不管CPU是什么体系结构。
C++ 编译的字节序跟CPU体系结构相关。
网络协议也都使用big endian顺序。所以big endian也叫网络字节序。

cpu在存储一个字节的8个比特时，同样有big endian和little endian的区别。
但因为CPU的最小操作单位是一个字节，因此比特序对程序来说是不可见的。
** Encoding
ASCII 
GB2312 6763个汉字 双字节
1995 gbk 21003个汉字 双字节
2000 gb18030 27484个汉字和主要的少数民族文字 双字节


向后兼容（同样的编码指向同样的字符）

双字节字符集 DBCS big-endian 高位在前
GB2312 高字节和低字节最高位都是1
GBK   高字节最高位一定是1. 低字节高位不一定是1
GB18030

所以如果读取到高位为1的字节，可以认定遇到了一个双字节编码

UNICODE编码和GB编码不兼容，只兼容ASCII(iso-8859-1)

Unicode = Universal Multiple-Octet Coded Character Set, UCS.

用两个字节编码： UCS-2

用四个字节编码： UCS-4 最高字节的最高位必须为0
根据最高字节分为 2^7 = 128 个group
每个group根据次高字节分为256个plane.
每个plane根据第三个字节分为256 row
每行包含 256 cells.
group 0 的 plane 0 被称作 Basic Multilingual Plane, 即 BMP。或者说 UCS-4 中,高两个
字节为 0 的码位被称作 BMP。

将 UCS-4 的 BMP 去掉前面的两个零字节就得到了 UCS-2。在 UCS-2 的两个字节前加上两个零
字节,就得到了 UCS-4 的 BMP。而目前的 UCS-4 规范中还没有任何字符被分配在 BMP 之外。

unicode.org 发起了 Unicode 项目。 ISO 发起了 ISO 10646项目。
从 Unicode2.0开始,Unicode 项目采用了与 ISO 10646-1 相同的字库和字码。

UTF = UCS Transformation Format
常见的UTF: utf-8, utf-16, utf-7.

UTF-8 就是以 8 位为单元对 UCS 进行编码。从 UCS-2 到 UTF-8 的编码方式如下:
UCS-2 编码(16 进制) UTF-8 字节流(二进制)
0000 - 007F 0xxxxxxx
0080 - 07FF 110xxxxx 10xxxxxx
0800 - FFFF 1110xxxx 10xxxxxx 10xxxxxx

UTF-16 以 16 位为单元对 UCS 进行编码。对于小于 0x10000 的 UCS 码,UTF-16 编码就等于
UCS 码对应的 16 位无符号整数。对于不小于 0x10000 的 UCS 码,定义了一个算法。不过由
于实际使用的 UCS2,或者 UCS4 的 BMP 必然小于 0x10000,所以就目前而言,可以认为 UTF-16
和 UCS-2 基本相同。但 UCS-2 只是一个编码方案,UTF-16 却要用于实际的传输,所以就不
得不考虑字节序的问题。
UTF-8 以字节为编码单元,没有字节序的问题。UTF-16 以两个字节为编码单元,在解释一个
UTF-16 文本前,首先要弄清楚每个编码单元的字节序。

Unicode 规范中推荐的标记字节顺序的方法是 BOM。(Byte Order Mark)。

BOM 是一个有点小聪明的想法:
在 UCS 编码中有一个叫做"ZERO WIDTH NO-BREAK SPACE"的字符,它的编码是 FEFF。而 FFFE
在 UCS 中是不存在的字符,所以不应该出现在实际传输中。UCS 规范建议我们在传输字节流
前,先传输字符"ZERO WIDTH NO-BREAK SPACE"。
这样如果接收者收到 FEFF,就表明这个字节流是 Big-Endian 的;如果收到 FFFE,就表明这
个字节流是 Little-Endian 的。因此字符"ZERO WIDTH NO-BREAK SPACE"又被称作 BOM。

UTF-8 不需要 BOM 来表明字节顺序,但可以用 BOM 来表明编码方式。字符"ZERO WIDTH
NO-BREAK SPACE"的 UTF-8 编码是 EF BB BF(读者可以用我们前面介绍的编码方法验证一下)。
所以如果接收者收到以 EF BB BF 开头的字节流,就知道这是 UTF-8 编码了。

iso-8859-1 为ISOIEC 8859-1:1998，又称Latin-1;
它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入96个字母及符号.

与ASCII的区别，ASCII是7bit字符集，ISO 8859-1 为8bit字符集，那为什么UTF-8可以完全至此ASCII，却不是完全至此ISO 8859-1，因为在UTF-8标准中，一个Byte的字符需要是0xxxxxxx格式的(0x00 ~ 0x7F)，但ISO-8859-1的部分字符

超过了这个范围。
** 进程管理
每个线程有自己的堆栈
每个DLL有自己的堆
** 负数表示
为什么要用补码，要用加法器进行运算
用补码表示，反码 + 1
从补码得到原码： -1 取反
** 内存对齐
** Unix进程和线程编程
编写一 unix 程序,防止僵尸进程的出现.
*** 进程间通信
1. 消息通信，以消息为单位进行通信
2. 管道通信，以自然字符流进行写入/读出
3. 低级通信一般通过变量和数组来通信
* 数据库
** 存储过程
* 算法
** find repeat in array
* 网络
* 云计算
** 定义
云计算是一种按使用量进行付费的模式，这种模式提供可用的、便捷的、按需的网络访问，使用可配置的计算资源共享池，共享池的资源包括网络、服务器、存储、应用软件、服务等，这些资源能够通过云计算平台快速提供给客户，只需投入很少的管理工作，或与服务供应商进行很少的交互。
—— NIST(美国国家标准与技术研究院)

云计算被称为是继大型计算机、个人计算机、互联网之后的第四次IT产业革命。
** 服务模式
*** SaaS (Software as a Service)
软件即服务
*** PaaS (Platform as a Service)
平台即服务，包含开发环境、编程语言、编译、测试、部署工具等，比如GAE。
*** IaaS (Infrastructure as a Service)
基础架构即服务，提供虚拟机、云存储等服务。最有名的服务提供商是Amazon.
** Hadoop
而Hadoop是Apache基金会下的一款开源软件，它实现了包括分布式文件系统和MapReduce框架在内的云计算软件平台的基础架构，并且在其上整合了包括数据库、云计算管理、数据仓储等一系列平台，其已成为工业界和学术界进行云计算应用和研究的标准平台。
如果对Hadoop进行严格定义，那么Hadoop是一种针对大数据处理和分析的开源分布式计算平台，是一个基于Java的开源软件架构，运行分布的、数据密集型应用。
*** Modules
**** Hadoop common
The common utilities that support the other Hadoop modules.
**** Hadoop Distributed File System (HDFS)
**** Hadoop YARN
A framework for job scheduling and cluster resource management.
**** Hadoop MapReduce
A YARN-based system for parallel processing of large data sets.
* research
面向 Internet 的时序数据快速分发技术研究
1)互联网资源组织和分配模型。
提出互联网资源的动态分配和组织模型，改善了服务的可用性。

优选服务结点：节点的服务类型和抗耗能力。
组织模型：以某种图组织，某种算法路由。

2)基于二分匹配的请求匹配算法。
定义了最优吞吐量调度问题,提出基于最大二分匹配的请求匹配算法 BBS,
达到了提高带宽利用率,改善传输吞吐量的目标。

3) 时序约束下快速分发的服务调度算法。
提出了分布式的服务调度算法 DSF,达到了在更好地满足时序约束的前提下加速数据分发的目标。
根据数据块的紧急程度和被需要的程度定义紧急块，
优先发送紧急块给后续最优服务能力的结点。

4) 功能可扩展的 P2P 模拟器设计。
设计和实现了功能上易于扩展的 P2P 流媒体模拟器 EPSS。通过清晰的模块划分和可扩展设
计,EPSS 不仅能支持时序数据分发中请求匹配技术和服务调度技术的研究,还能
方便地通过扩展以支持 overlay 构建技术的研究和网络动态环境的仿真。

5) 基于 iVCE 平台的应用验证。
PaaS模式的云计算平台，提供Owlet应用开发语言和编译环境。
定义角色Requestor和Provider，部署了流媒体应用。
综合应用了BBS请求端调度算法和DSF服务端调度算法。
* To understand
1. 68
